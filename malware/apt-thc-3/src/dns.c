#include "dns.h"
#include "utils.h"

#include <unistd.h>

void parse_header (struct dns_header *header) {
	header->id = ntohs(header->id);
	header->q_count = ntohs(header->q_count);
	header->ans_count = ntohs(header->ans_count);
	header->auth_count = ntohs(header->auth_count);
	header->add_count = ntohs(header->add_count);
}

void prepare_header (struct dns_header *header) {
	header->id = htons(header->id);
	header->q_count = htons(header->q_count);
	header->ans_count = htons(header->ans_count);
	header->auth_count = htons(header->auth_count);
	header->add_count = htons(header->add_count);
}

struct dns_question *parse_request (struct dns_packet *pkt) {
	int i = 0;
	struct domain_list *domains = NULL;
	size_t question_size = 0, domains_count = 0;
	struct dns_question *question = NULL;

	parse_header(&pkt->header);

	if(pkt->header.q_count > 0) {
		if (!(question = malloc(sizeof (struct dns_question)))) {
			perror("malloc");
			exit(1);
		}

		domains = create_list();

		while (pkt->data[i]) {
			question_size = (unsigned char) pkt->data[i++];
			insert_domain(domains, &pkt->data[i], question_size);
			i += question_size;
			domains_count++;
		}

		if (domains_count == 0) {
			free(domains);
			domains = NULL;
		}

		i++;

		question->domains_count = domains_count;
		question->domains = domains;

		question->type = ntohs(*((unsigned short *) (&pkt->data[i])));
		question->class = ntohs(*((unsigned short *) (&pkt->data[i+2])));
		question->real_size = i + 4;
	}

	return question;
}

struct dns_packet *resolve_query(struct dns_packet *pkt, struct dns_question *question, char *data, unsigned short size)  {
	struct dns_answer answer;
	struct dns_packet *answer_packet;
	unsigned char txt_size;
	char *data_ptr;

	if (!(answer_packet = malloc(sizeof (struct dns_packet)))) {
		perror("malloc");
		exit(1);
	}

	txt_size = question->type == TYPE_TXT;

	if (question->real_size + txt_size + sizeof(struct dns_answer) > BUFFER_SIZE) {
		size = BUFFER_SIZE - question->real_size - txt_size - sizeof(struct dns_answer);
	}

	answer_packet->client = pkt->client;
	answer_packet->client_len = pkt->client_len;

	memcpy(&answer_packet->header, &pkt->header, sizeof(struct dns_header));

	answer_packet->header.qr = 1;
	answer_packet->header.ans_count = 1;
	answer_packet->header.add_count = 0;

	prepare_header(&answer_packet->header);

	data_ptr = answer_packet->data;

	memcpy(data_ptr, pkt->data, question->real_size);
	data_ptr += question->real_size;


	answer.magic = htons(0xc00c);
	answer.type = htons(question->type);
	answer.class = htons(question->class);
	answer.ttl = htonl(0x1337);
	answer.size = htons(size + txt_size);

	memcpy(data_ptr, &answer, sizeof(struct dns_answer));

	data_ptr += sizeof(struct dns_answer);

	if (question->type == TYPE_TXT) {
		answer.size++;
		*data_ptr++ = (unsigned char) size; 
	}

	memcpy(data_ptr, data, size);

	answer_packet->size = question->real_size + sizeof (struct dns_answer) + txt_size + size;

	return answer_packet;
}